import{_ as e,c as a,o as l,a2 as i}from"./chunks/framework.CzlNzQcO.js";const f=JSON.parse('{"title":"vue相关","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/vue.md","filePath":"knowledge/vue.md"}'),t={name:"knowledge/vue.md"},o=i('<h1 id="vue相关" tabindex="-1">vue相关 <a class="header-anchor" href="#vue相关" aria-label="Permalink to &quot;vue相关&quot;">​</a></h1><h2 id="完整的导航解析流程" tabindex="-1">完整的导航解析流程 <a class="header-anchor" href="#完整的导航解析流程" aria-label="Permalink to &quot;完整的导航解析流程&quot;">​</a></h2><ul><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ul><h2 id="virtual-dom-算法简述" tabindex="-1">Virtual Dom 算法简述 <a class="header-anchor" href="#virtual-dom-算法简述" aria-label="Permalink to &quot;Virtual Dom 算法简述&quot;">​</a></h2><ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li><li>一旦节点有子元素，就去判断子元素是否有不同</li></ul><h2 id="virtual-dom-算法实现" tabindex="-1">Virtual Dom 算法实现 <a class="header-anchor" href="#virtual-dom-算法实现" aria-label="Permalink to &quot;Virtual Dom 算法实现&quot;">​</a></h2><h3 id="树的递归" tabindex="-1">树的递归 <a class="header-anchor" href="#树的递归" aria-label="Permalink to &quot;树的递归&quot;">​</a></h3><ol><li>新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了</li><li>新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树</li><li>没有新的节点，那么什么都不用做</li></ol><h3 id="判断属性的更改" tabindex="-1">判断属性的更改 <a class="header-anchor" href="#判断属性的更改" aria-label="Permalink to &quot;判断属性的更改&quot;">​</a></h3><ol><li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li><li>遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化</li><li>在第二步中同时查看是否有属性不存在与旧的属性列列表中</li></ol><h3 id="判断列表差异算法实现" tabindex="-1">判断列表差异算法实现 <a class="header-anchor" href="#判断列表差异算法实现" aria-label="Permalink to &quot;判断列表差异算法实现&quot;">​</a></h3><ol><li>遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</li><li>遍历新的节点列表，判断是否有新的节点</li><li>在第二步中同时判断节点是否有移动</li></ol><h3 id="遍历子元素打标识" tabindex="-1">遍历子元素打标识 <a class="header-anchor" href="#遍历子元素打标识" aria-label="Permalink to &quot;遍历子元素打标识&quot;">​</a></h3><ol><li>判断两个列表差异</li><li>给节点打上标记</li></ol><h3 id="渲染差异" tabindex="-1">渲染差异 <a class="header-anchor" href="#渲染差异" aria-label="Permalink to &quot;渲染差异&quot;">​</a></h3><ol><li>深度遍历树，将需要做变更操作的取出来</li><li>局部更新 DOM</li></ol><h2 id="vue-的双向数据绑定实现原理" tabindex="-1">Vue 的双向数据绑定实现原理 <a class="header-anchor" href="#vue-的双向数据绑定实现原理" aria-label="Permalink to &quot;Vue 的双向数据绑定实现原理&quot;">​</a></h2><ul><li>数据劫持：使用 Object.defineProperty 劫持对象属性的 get 和 set。</li><li>依赖收集：在属性 get 时，收集当前的 Watcher 实例作为依赖。</li><li>Watcher 实例：创建 Watcher 实例来订阅属性变化，并在属性变化时执行回调。</li><li>事件通知：在属性 set 时，通知所有依赖于该属性的 Watcher 实例更新。</li></ul><h2 id="如何在-vue-中进行组件间的通信-并列举几种常见的方法" tabindex="-1">如何在 Vue 中进行组件间的通信，并列举几种常见的方法 <a class="header-anchor" href="#如何在-vue-中进行组件间的通信-并列举几种常见的方法" aria-label="Permalink to &quot;如何在 Vue 中进行组件间的通信，并列举几种常见的方法&quot;">​</a></h2><ul><li>父子组件通信： 使用 props 和 emit。</li><li>非父子组件通信： 使用全局事件总线、Vuex、provide/inject 等。</li></ul><h2 id="如何优化-vue-应用的性能-请列举几种方法" tabindex="-1">如何优化 Vue 应用的性能？请列举几种方法 <a class="header-anchor" href="#如何优化-vue-应用的性能-请列举几种方法" aria-label="Permalink to &quot;如何优化 Vue 应用的性能？请列举几种方法&quot;">​</a></h2><ol><li>懒加载组件</li><li>使用 v-once：对于静态内容使用 v-once 指令，使其只渲染一次。</li><li>使用 v-for 时加 key：在使用 v-for 渲染列表时，确保提供唯一的 key。</li><li>减少 watch 数量：避免过多的 watch，尽量使用计算属性（computed properties）。</li><li>适当的分片更新：使用 requestAnimationFrame 或 setTimeout 分片更新数据，避免长时间的阻塞。</li><li>事件代理：对于大量的事件监听，可以使用事件代理来减少内存占用。</li></ol>',22),r=[o];function h(u,n,d,c,s,m){return l(),a("div",null,r)}const v=e(t,[["render",h]]);export{f as __pageData,v as default};
