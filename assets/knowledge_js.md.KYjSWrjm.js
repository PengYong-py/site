import{_ as e,c as t,o as a,a2 as i}from"./chunks/framework.CzlNzQcO.js";const _=JSON.parse('{"title":"js相关","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/js.md","filePath":"knowledge/js.md"}'),o={name:"knowledge/js.md"},r=i('<h1 id="js相关" tabindex="-1">js相关 <a class="header-anchor" href="#js相关" aria-label="Permalink to &quot;js相关&quot;">​</a></h1><h2 id="请解释一下javascript中的闭包-closure-以及闭包的实际应用场景。" tabindex="-1">请解释一下JavaScript中的闭包（closure），以及闭包的实际应用场景。 <a class="header-anchor" href="#请解释一下javascript中的闭包-closure-以及闭包的实际应用场景。" aria-label="Permalink to &quot;请解释一下JavaScript中的闭包（closure），以及闭包的实际应用场景。&quot;">​</a></h2><p>闭包是指在函数内部定义的函数可以访问其外部函数的变量。换句话说，闭包是由函数和其词法环境的组合而成，这个环境包含了这个函数在定义时所能访问的所有局部变量。</p><p>数据隐藏和封装： 函数工厂 闭包可以用于模块化开发，定义模块的私有成员和公开接口。</p><h2 id="请解释一下javascript的事件冒泡-event-bubbling-和事件捕获-event-capturing-机制-并说明如何使用事件委托-event-delegation-优化事件处理。" tabindex="-1">请解释一下JavaScript的事件冒泡（event bubbling）和事件捕获（event capturing）机制，并说明如何使用事件委托（event delegation）优化事件处理。 <a class="header-anchor" href="#请解释一下javascript的事件冒泡-event-bubbling-和事件捕获-event-capturing-机制-并说明如何使用事件委托-event-delegation-优化事件处理。" aria-label="Permalink to &quot;请解释一下JavaScript的事件冒泡（event bubbling）和事件捕获（event capturing）机制，并说明如何使用事件委托（event delegation）优化事件处理。&quot;">​</a></h2><ul><li>事件冒泡:事件冒泡是指事件从最具体的元素（事件的目标元素）开始，逐级向上传播到最不具体的元素（通常是文档或窗口）。在事件冒泡阶段，事件处理程序按照从内到外的顺序执行。</li><li>事件捕获:事件捕获是指事件从最不具体的元素（通常是文档或窗口）开始，逐级向下传播到最具体的元素（事件的目标元素）。在事件捕获阶段，事件处理程序按照从外到内的顺序执行。</li><li>事件委托:事件委托是一种利用事件冒泡机制，将事件处理程序添加到父元素，而不是每个子元素上，从而优化性能和简化代码。当子元素数量众多或频繁变化时，事件委托尤其有用。</li><li>事件冒泡：事件从最具体的元素向上传播到最不具体的元素。</li><li>事件捕获：事件从最不具体的元素向下传播到最具体的元素。</li><li>事件委托：利用事件冒泡，将事件处理程序添加到父元素，从而优化性能和简化代码。</li></ul><h2 id="请解释一下javascript的原型-prototype-和原型链-prototype-chain-以及它们在继承中的作用。" tabindex="-1">请解释一下JavaScript的原型（prototype）和原型链（prototype chain），以及它们在继承中的作用。 <a class="header-anchor" href="#请解释一下javascript的原型-prototype-和原型链-prototype-chain-以及它们在继承中的作用。" aria-label="Permalink to &quot;请解释一下JavaScript的原型（prototype）和原型链（prototype chain），以及它们在继承中的作用。&quot;">​</a></h2><ul><li><p>JavaScript的原型（prototype）和原型链（prototype chain）：在JavaScript中，每个对象都有一个隐藏的属性[[Prototype]]（通常可以通过__proto__访问），它指向该对象的原型对象。原型对象本身也有一个[[Prototype]]，指向更高一级的原型对象，如此形成一个链条，称为原型链。</p></li><li><p>原型和原型链的工作原理：当你访问一个对象的属性时，JavaScript会首先在该对象自身上查找该属性。如果找不到，它会沿着原型链向上查找，直到找到该属性或到达原型链的顶端（即Object.prototype）。 原型链中的继承：原型链在继承中起到重要作用，使对象可以共享方法和属性，从而实现代码复用。</p></li></ul><h2 id="请解释一下javascript的事件循环-event-loop-机制-以及它是如何处理异步任务的。" tabindex="-1">请解释一下JavaScript的事件循环（Event Loop）机制，以及它是如何处理异步任务的。 <a class="header-anchor" href="#请解释一下javascript的事件循环-event-loop-机制-以及它是如何处理异步任务的。" aria-label="Permalink to &quot;请解释一下JavaScript的事件循环（Event Loop）机制，以及它是如何处理异步任务的。&quot;">​</a></h2><ul><li>执行宏任务（Task）：从任务队列（Task Queue）中取出第一个宏任务并执行。宏任务包括初始化代码、setTimeout、setInterval、I/O操作等。</li><li>查询是否有微任务（Microtask）：在每个宏任务执行完后，事件循环会检查微任务队列（Microtask Queue）是否为空。微任务包括Promise的回调函数、MutationObserver等。</li><li>执行微任务：如果有微任务，将它们全部执行完。执行过程中产生的新微任务会被添加到微任务队列中，直到队列为空。</li><li>检查是否需要重新渲染页面：在每次宏任务和所有微任务执行完之后，浏览器会检查是否需要重新渲染页面（UI更新）。</li><li>重复上述步骤：事件循环重复上述步骤，不断地从宏任务队列中取任务执行。</li><li>宏任务（Task）：包括setTimeout、setInterval、I/O等。</li><li>微任务（Microtask）：包括Promise的回调、MutationObserver等。</li><li>事件循环（Event Loop）：不断执行宏任务和微任务，确保JavaScript能够高效地处理异步任务。</li></ul>',10),l=[r];function n(p,c,s,v,u,h){return a(),t("div",null,l)}const b=e(o,[["render",n]]);export{_ as __pageData,b as default};
