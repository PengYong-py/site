import{_ as t,c as a,o as l,a2 as r}from"./chunks/framework.CzlNzQcO.js";const g=JSON.parse('{"title":"网络相关","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/http.md","filePath":"knowledge/http.md"}'),e={name:"knowledge/http.md"},o=r(`<h1 id="网络相关" tabindex="-1">网络相关 <a class="header-anchor" href="#网络相关" aria-label="Permalink to &quot;网络相关&quot;">​</a></h1><h2 id="udp-与-tcp-的区别是什么" tabindex="-1">UDP 与 TCP 的区别是什么？ <a class="header-anchor" href="#udp-与-tcp-的区别是什么" aria-label="Permalink to &quot;UDP 与 TCP 的区别是什么？&quot;">​</a></h2><p>UDP（User Datagram Protocol）和 TCP（Transmission Control Protocol）是两个最常用的传输层协议，它们在许多方面有所不同，包括连接方式、数据传输可靠性、速度和使用场景。以下是它们的主要区别：</p><h3 id="_1-连接方式" tabindex="-1">1. 连接方式 <a class="header-anchor" href="#_1-连接方式" aria-label="Permalink to &quot;1. 连接方式&quot;">​</a></h3><ul><li><strong>TCP</strong>：面向连接的协议。在发送数据之前，必须先建立一个可靠的连接（通过三次握手）。在数据传输完成后，连接需要关闭（通过四次挥手）。</li><li><strong>UDP</strong>：无连接的协议。发送数据之前不需要建立连接，数据包（数据报文）直接被发送到目的地。</li></ul><h3 id="_2-数据传输可靠性" tabindex="-1">2. 数据传输可靠性 <a class="header-anchor" href="#_2-数据传输可靠性" aria-label="Permalink to &quot;2. 数据传输可靠性&quot;">​</a></h3><ul><li><strong>TCP</strong>：提供可靠的数据传输，确保数据包按顺序、无丢失、无重复地到达接收方。TCP 实现了流量控制和拥塞控制。</li><li><strong>UDP</strong>：不提供可靠的数据传输，不保证数据包的顺序和完整性。数据包可能会丢失、重复或乱序到达接收方。</li></ul><h3 id="_3-速度和开销" tabindex="-1">3. 速度和开销 <a class="header-anchor" href="#_3-速度和开销" aria-label="Permalink to &quot;3. 速度和开销&quot;">​</a></h3><ul><li><strong>TCP</strong>：由于需要建立和维护连接，以及进行确认、重传、流量控制和拥塞控制，TCP 的开销较大，传输速度相对较慢。</li><li><strong>UDP</strong>：由于不需要建立连接，也不进行确认和重传，UDP 的开销较小，传输速度更快。</li></ul><h3 id="_4-数据传输方式" tabindex="-1">4. 数据传输方式 <a class="header-anchor" href="#_4-数据传输方式" aria-label="Permalink to &quot;4. 数据传输方式&quot;">​</a></h3><ul><li><strong>TCP</strong>：基于字节流的传输，数据以流的形式传输，数据可以被分割和重新组合。</li><li><strong>UDP</strong>：基于数据报的传输，数据以独立的报文形式传输，每个数据包是一个独立的单元。</li></ul><h3 id="_5-使用场景" tabindex="-1">5. 使用场景 <a class="header-anchor" href="#_5-使用场景" aria-label="Permalink to &quot;5. 使用场景&quot;">​</a></h3><ul><li><strong>TCP</strong>：适用于需要可靠传输的应用，如网页浏览（HTTP/HTTPS）、电子邮件（SMTP）、文件传输（FTP）等。</li><li><strong>UDP</strong>：适用于实时性要求高但对可靠性要求较低的应用，如视频流（视频会议、直播）、音频流（VoIP）、在线游戏等。</li></ul><h3 id="_6-头部开销" tabindex="-1">6. 头部开销 <a class="header-anchor" href="#_6-头部开销" aria-label="Permalink to &quot;6. 头部开销&quot;">​</a></h3><ul><li><strong>TCP</strong>：头部较大，通常包含 20 字节的基本头部，再加上可选字段。</li><li><strong>UDP</strong>：头部较小，固定为 8 字节。</li></ul><h3 id="具体比较" tabindex="-1">具体比较 <a class="header-anchor" href="#具体比较" aria-label="Permalink to &quot;具体比较&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接方式</td><td>面向连接（连接建立和关闭）</td><td>无连接</td></tr><tr><td>数据传输可靠性</td><td>可靠（顺序、无丢失、无重复）</td><td>不可靠（可能丢失、重复、乱序）</td></tr><tr><td>速度和开销</td><td>较慢，开销大</td><td>较快，开销小</td></tr><tr><td>数据传输方式</td><td>字节流传输</td><td>数据报传输</td></tr><tr><td>使用场景</td><td>需要可靠传输的应用</td><td>实时性高但可靠性要求低的应用</td></tr><tr><td>头部开销</td><td>20 字节 + 可选字段</td><td>8 字节</td></tr></tbody></table><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong>TCP</strong> 提供可靠性、顺序和数据完整性，适用于要求高可靠性的应用场景。</li><li><strong>UDP</strong> 提供更高的传输速度和更低的开销，适用于对实时性要求高、对可靠性要求不高的应用场景。</li></ul><h2 id="get-和-post区别" tabindex="-1">GET 和 POST区别 <a class="header-anchor" href="#get-和-post区别" aria-label="Permalink to &quot;GET 和 POST区别&quot;">​</a></h2><p>HTTP 协议中的 GET 和 POST 是两种常用的请求方法，它们的主要区别如下：</p><h3 id="_1-参数传递方式" tabindex="-1">1. 参数传递方式 <a class="header-anchor" href="#_1-参数传递方式" aria-label="Permalink to &quot;1. 参数传递方式&quot;">​</a></h3><ul><li><p><strong>GET</strong>：</p><ul><li>参数通过 URL 传递，通常附加在 URL 的末尾，以 <code>?</code> 分隔，多个参数之间用 <code>&amp;</code> 分隔。</li><li>示例：<code>GET /page?name=value&amp;foo=bar HTTP/1.1</code></li></ul></li><li><p><strong>POST</strong>：</p><ul><li>参数放在请求体（body）中，通过 HTTP 消息的主体传递。</li><li>示例：<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>POST /page HTTP/1.1</span></span>
<span class="line"><span>Host: example.com</span></span>
<span class="line"><span>Content-Type: application/x-www-form-urlencoded</span></span>
<span class="line"><span>Content-Length: 27</span></span>
<span class="line"><span></span></span>
<span class="line"><span>name=value&amp;foo=bar</span></span></code></pre></div></li></ul></li></ul><h3 id="_2-安全性" tabindex="-1">2. 安全性 <a class="header-anchor" href="#_2-安全性" aria-label="Permalink to &quot;2. 安全性&quot;">​</a></h3><ul><li><p><strong>GET</strong>：</p><ul><li>参数直接暴露在 URL 中，可能会被记录在浏览器历史记录、服务器日志和其他地方，因此敏感信息不应使用 GET 传递。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>参数在请求体中传递，虽然不能完全避免被截取，但相对更安全，适合传递敏感信息。</li></ul></li></ul><h3 id="_3-数据长度" tabindex="-1">3. 数据长度 <a class="header-anchor" href="#_3-数据长度" aria-label="Permalink to &quot;3. 数据长度&quot;">​</a></h3><ul><li><p><strong>GET</strong>：</p><ul><li>由于 URL 长度限制（不同浏览器和服务器有不同的限制，一般为 2048 字符），GET 请求传递的数据长度有限。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>理论上数据长度无限制（实际上受限于服务器配置和内存大小），可以传递大量数据。</li></ul></li></ul><h3 id="_4-浏览器缓存" tabindex="-1">4. 浏览器缓存 <a class="header-anchor" href="#_4-浏览器缓存" aria-label="Permalink to &quot;4. 浏览器缓存&quot;">​</a></h3><ul><li><p><strong>GET</strong>：</p><ul><li>请求会被浏览器缓存，适合用于获取相同数据的请求，如静态资源和查询操作。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>请求不会被浏览器缓存，适合用于需要提交数据并且希望每次请求都能执行相同操作的场景，如表单提交。</li></ul></li></ul><h3 id="_5-幂等性" tabindex="-1">5. 幂等性 <a class="header-anchor" href="#_5-幂等性" aria-label="Permalink to &quot;5. 幂等性&quot;">​</a></h3><ul><li><p><strong>GET</strong>：</p><ul><li>幂等的，多次请求同一个 URL 应该得到相同的响应，不会产生副作用。适合用于获取数据。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>非幂等的，多次相同的请求可能会产生不同的结果，可能会创建或修改资源。适合用于提交数据。</li></ul></li></ul><h3 id="_6-书签和重定向" tabindex="-1">6. 书签和重定向 <a class="header-anchor" href="#_6-书签和重定向" aria-label="Permalink to &quot;6. 书签和重定向&quot;">​</a></h3><ul><li><p><strong>GET</strong>：</p><ul><li>可以被书签保存，浏览器允许对 GET 请求进行重定向。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>不能被书签保存，浏览器不允许对 POST 请求进行重定向。</li></ul></li></ul><h3 id="具体比较-1" tabindex="-1">具体比较 <a class="header-anchor" href="#具体比较-1" aria-label="Permalink to &quot;具体比较&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>参数传递方式</td><td>URL 末尾，通过查询字符串传递</td><td>请求体中，通过消息主体传递</td></tr><tr><td>安全性</td><td>参数暴露在 URL 中，不适合传递敏感信息</td><td>参数在请求体中，相对更安全，适合传递敏感信息</td></tr><tr><td>数据长度</td><td>有限（受 URL 长度限制）</td><td>理论上无限制（受服务器配置限制）</td></tr><tr><td>浏览器缓存</td><td>会被浏览器缓存</td><td>不会被浏览器缓存</td></tr><tr><td>幂等性</td><td>幂等，适合获取数据</td><td>非幂等，适合提交数据</td></tr><tr><td>书签和重定向</td><td>可以被书签保存，允许重定向</td><td>不能被书签保存，不允许重定向</td></tr></tbody></table><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong>GET</strong> 方法主要用于获取数据，具有较好的性能和缓存机制，但不适合传递敏感信息和大量数据。</li><li><strong>POST</strong> 方法主要用于提交数据，安全性较高，适合传递敏感信息和大量数据，但不具备 GET 的缓存和幂等特性。</li></ul><h2 id="vue-router-几种模式的区别" tabindex="-1">vue-router 几种模式的区别 <a class="header-anchor" href="#vue-router-几种模式的区别" aria-label="Permalink to &quot;vue-router 几种模式的区别&quot;">​</a></h2>`,38),i=[o];function n(d,s,h,u,p,c){return l(),a("div",null,i)}const T=t(e,[["render",n]]);export{g as __pageData,T as default};
