# vue相关

## 完整的导航解析流程

- 导航被触发。
- 在失活的组件里调用 beforeRouteLeave 守卫。
- 调用全局的 beforeEach 守卫。
- 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。
- 在路由配置里调用 beforeEnter。
- 解析异步路由组件。
- 在被激活的组件里调用 beforeRouteEnter。
- 调用全局的 beforeResolve 守卫(2.5+)。
- 导航被确认。
- 调用全局的 afterEach 钩子。
- 触发 DOM 更新。
- 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

## Virtual Dom 算法简述

- 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异
- 一旦节点有子元素，就去判断子元素是否有不同

## Virtual Dom 算法实现

### 树的递归
1. 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了
2. 新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树
3. 没有新的节点，那么什么都不用做

### 判断属性的更改
1. 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中
2. 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化
3. 在第二步中同时查看是否有属性不存在与旧的属性列列表中
### 判断列表差异算法实现

1. 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中
2. 遍历新的节点列表，判断是否有新的节点
3. 在第二步中同时判断节点是否有移动

### 遍历子元素打标识
1. 判断两个列表差异
2. 给节点打上标记

### 渲染差异
1. 深度遍历树，将需要做变更操作的取出来
2. 局部更新 DOM

## Vue 的双向数据绑定实现原理
- 数据劫持：使用 Object.defineProperty 劫持对象属性的 get 和 set。
- 依赖收集：在属性 get 时，收集当前的 Watcher 实例作为依赖。
- Watcher 实例：创建 Watcher 实例来订阅属性变化，并在属性变化时执行回调。
- 事件通知：在属性 set 时，通知所有依赖于该属性的 Watcher 实例更新。

## 如何在 Vue 中进行组件间的通信，并列举几种常见的方法
- 父子组件通信： 使用 props 和 emit。
-  非父子组件通信： 使用全局事件总线、Vuex、provide/inject 等。

## 如何优化 Vue 应用的性能？请列举几种方法
1. 懒加载组件
2. 使用 v-once：对于静态内容使用 v-once 指令，使其只渲染一次。
3. 使用 v-for 时加 key：在使用 v-for 渲染列表时，确保提供唯一的 key。
4. 减少 watch 数量：避免过多的 watch，尽量使用计算属性（computed properties）。
5. 适当的分片更新：使用 requestAnimationFrame 或 setTimeout 分片更新数据，避免长时间的阻塞。
6. 事件代理：对于大量的事件监听，可以使用事件代理来减少内存占用。