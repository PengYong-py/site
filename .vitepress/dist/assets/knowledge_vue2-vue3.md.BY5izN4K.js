import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.CzlNzQcO.js";const c=JSON.parse('{"title":"vue2 vs vue3","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/vue2-vue3.md","filePath":"knowledge/vue2-vue3.md"}'),l={name:"knowledge/vue2-vue3.md"},t=n(`<h1 id="vue2-vs-vue3" tabindex="-1">vue2 vs vue3 <a class="header-anchor" href="#vue2-vs-vue3" aria-label="Permalink to &quot;vue2 vs vue3&quot;">​</a></h1><h2 id="基础对比问题" tabindex="-1">基础对比问题 <a class="header-anchor" href="#基础对比问题" aria-label="Permalink to &quot;基础对比问题&quot;">​</a></h2><p><strong>1. Vue 2 和 Vue 3 的主要区别是什么？</strong></p><ul><li>Vue 3 引入了 Composition API，这是一种新的组件编写方式，能够更好地处理复杂逻辑和代码复用。</li><li>Vue 3 使用了 Proxy 对象来实现响应式系统，相比 Vue 2 的基于 <code>Object.defineProperty</code> 的实现更高效。</li><li>Vue 3 支持 Tree-shaking，可以在打包时去除未使用的代码，减小最终包的体积。</li></ul><p><strong>2. Vue 3 引入了哪些新特性？</strong></p><ul><li>Composition API (<code>setup</code> 函数)</li><li>Fragments</li><li>Teleport</li><li>Multiple root elements</li><li>Improved TypeScript support</li><li>Custom Renderer API</li></ul><p><strong>3. Vue 3 对性能进行了哪些优化？</strong></p><ul><li>更快的 Virtual DOM diff 算法</li><li>更高效的组件初始化和更新过程</li><li>使用 Proxy 对象实现响应式，减少依赖追踪的开销</li><li>支持 Tree-shaking 减少打包体积</li></ul><p><strong>4. Vue 3 的 Composition API 与 Vue 2 的 Options API 有什么区别？</strong></p><ul><li>Composition API 使用 <code>setup</code> 函数，可以将相关逻辑组合在一起，提高代码的组织性和可复用性。</li><li>Options API 是基于对象的配置方式，不同的功能分散在 <code>data</code>, <code>methods</code>, <code>computed</code>, <code>watch</code> 等选项中。</li></ul><h2 id="composition-api-相关问题" tabindex="-1">Composition API 相关问题 <a class="header-anchor" href="#composition-api-相关问题" aria-label="Permalink to &quot;Composition API 相关问题&quot;">​</a></h2><p><strong>5. 请解释 Vue 3 的 Composition API。它解决了哪些问题？</strong></p><ul><li>Composition API 通过 <code>setup</code> 函数提供一种组织代码的新方式，能够更好地复用和组织逻辑。</li><li>解决了 Options API 中同一功能分散在多个选项中的问题，使代码更加模块化和易维护。</li></ul><p><strong>6. 如何在 Vue 3 中使用 <code>setup</code> 函数？</strong></p><ul><li><p><code>setup</code> 函数是一个组件的入口函数，返回一个对象，这个对象的属性会暴露给模板使用。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increment</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count, increment };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li></ul><p><strong>7. Composition API 和 Mixins 相比有什么优势？</strong></p><ul><li>Composition API 避免了 Mixins 中的命名冲突和数据来源不明确的问题。</li><li>更好的逻辑复用和组合，减少了代码耦合。</li></ul><p><strong>8. 如何在 Composition API 中使用生命周期钩子？</strong></p><ul><li><p>使用 Vue 3 提供的生命周期钩子函数，如 <code>onMounted</code>, <code>onUpdated</code>, <code>onUnmounted</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { onMounted } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Component mounted&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li></ul><h2 id="reactivity-相关问题" tabindex="-1">Reactivity 相关问题 <a class="header-anchor" href="#reactivity-相关问题" aria-label="Permalink to &quot;Reactivity 相关问题&quot;">​</a></h2><p><strong>9. Vue 3 的响应式系统做了哪些改进？</strong></p><ul><li>Vue 3 使用 Proxy 对象实现响应式系统，提供了更灵活和高效的依赖追踪机制。</li><li>Proxy 可以直接监听数组和对象的变化，不需要像 <code>Object.defineProperty</code> 那样手动递归处理嵌套对象。</li></ul><p><strong>10. Vue 3 中的 <code>reactive</code> 和 <code>ref</code> 有什么区别？</strong></p><ul><li><p><code>reactive</code> 用于创建深层次的响应式对象。</p></li><li><p><code>ref</code> 用于创建基本类型的响应式数据或单一响应式引用。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ul><p><strong>11. 如何在 Vue 3 中创建一个响应式对象？</strong></p><ul><li><p>使用 <code>reactive</code> 或 <code>ref</code> 创建响应式对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { reactive, ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ul><p><strong>12. 请解释 Vue 3 的 <code>watch</code> 和 <code>watchEffect</code> 的区别。</strong></p><ul><li><code>watch</code> 是用于监听特定响应式数据的变化，并执行回调。</li><li><code>watchEffect</code> 立即执行传入的函数，并自动追踪函数内响应式数据的依赖，任何依赖变化都会重新执行函数。</li></ul><h2 id="模板语法与指令" tabindex="-1">模板语法与指令 <a class="header-anchor" href="#模板语法与指令" aria-label="Permalink to &quot;模板语法与指令&quot;">​</a></h2><p><strong>13. 在 Vue 3 中，模板语法有什么变化？</strong></p><ul><li>Vue 3 支持多个根元素的模板语法。</li><li>其他方面大致与 Vue 2 保持一致。</li></ul><p><strong>14. Vue 3 引入了哪些新的指令或对现有指令进行了哪些修改？</strong></p><ul><li>Vue 3 保留了 Vue 2 中的绝大多数指令，如 <code>v-model</code>, <code>v-if</code>, <code>v-for</code> 等。</li><li>新增了一些指令如 <code>v-memo</code>，用于性能优化。</li></ul><h2 id="组件和插件" tabindex="-1">组件和插件 <a class="header-anchor" href="#组件和插件" aria-label="Permalink to &quot;组件和插件&quot;">​</a></h2><p><strong>15. Vue 3 对组件注册做了哪些改进？</strong></p><ul><li>Vue 3 支持全局和局部的组件注册方式，但推荐使用局部注册以便于 Tree-shaking。</li></ul><p><strong>16. Vue 3 中的 <code>Teleport</code> 是什么？它的作用是什么？</strong></p><ul><li><p><code>Teleport</code> 允许将组件的 DOM 结构渲染到指定的 DOM 节点之外的位置。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">teleport</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#modal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Modal content&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">teleport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ul><p><strong>17. 如何在 Vue 3 中编写和使用插件？</strong></p><ul><li><p>Vue 3 插件的编写方式类似于 Vue 2，但可以利用 Composition API 提供更多功能。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MyPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  install</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    app.config.globalProperties.$myPlugin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;My Plugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyPlugin);</span></span></code></pre></div></li></ul><h2 id="编译和打包" tabindex="-1">编译和打包 <a class="header-anchor" href="#编译和打包" aria-label="Permalink to &quot;编译和打包&quot;">​</a></h2><p><strong>18. Vue 3 对编译和打包做了哪些改进？</strong></p><ul><li>支持 Tree-shaking，减少未使用代码的打包。</li><li>更好的 TypeScript 支持。</li><li>提供了自定义渲染器 API。</li></ul><p><strong>19. 如何在 Vue 3 中使用 Tree-shaking？</strong></p><ul><li>确保项目的打包工具（如 Webpack, Rollup）支持 Tree-shaking。</li><li>使用局部组件注册和按需引入库。</li></ul><h2 id="兼容性和迁移" tabindex="-1">兼容性和迁移 <a class="header-anchor" href="#兼容性和迁移" aria-label="Permalink to &quot;兼容性和迁移&quot;">​</a></h2><p><strong>20. Vue 2 项目迁移到 Vue 3 需要注意哪些事项？</strong></p><ul><li>检查不兼容的 API 和指令。</li><li>逐步迁移到 Composition API。</li><li>使用官方提供的迁移工具和兼容性模式。</li></ul><p><strong>21. Vue 3 提供了哪些工具或方法来帮助迁移？</strong></p><ul><li>官方提供的迁移指南和迁移构建工具。</li><li>兼容性构建模式，可以逐步迁移。</li></ul><p><strong>22. Vue 3 的兼容性模式是什么？</strong></p><ul><li>兼容性模式允许使用 Vue 3 的新特性，同时保留大部分 Vue 2 的 API。</li></ul><h2 id="实践和案例" tabindex="-1">实践和案例 <a class="header-anchor" href="#实践和案例" aria-label="Permalink to &quot;实践和案例&quot;">​</a></h2><p><strong>23. 请举例说明在实际项目中从 Vue 2 升级到 Vue 3 的过程。</strong></p><ul><li>分析项目中使用的 Vue 2 特性。</li><li>使用 Vue 3 的兼容性构建进行初步迁移。</li><li>逐步替换 Vue 2 特性为 Vue 3 特性，如使用 Composition API 代替 Mixins。</li></ul><p><strong>24. 在 Vue 3 中，如何处理与第三方库的兼容性问题？</strong></p><ul><li>检查第三方库是否已经支持 Vue 3。</li><li>如果没有，寻找替代库或自行封装适配代码。</li></ul><h2 id="综合对比" tabindex="-1">综合对比 <a class="header-anchor" href="#综合对比" aria-label="Permalink to &quot;综合对比&quot;">​</a></h2><p><strong>25. Vue 3 在代码可维护性和可读性上做了哪些改进？</strong></p><ul><li>Composition API 提高了代码的组织性和复用性。</li><li>更好的 TypeScript 支持，提供更强的类型检查和提示。</li></ul><p><strong>26. 在 Vue 2 和 Vue 3 中，如何处理全局状态管理？</strong></p><ul><li>Vue 2 通常使用 Vuex。</li><li>Vue 3 推荐使用 Vuex 4 或者新的状态管理解决方案如 Pinia，利用 Composition API 进行状态管理。</li></ul><p><strong>27. 请比较 Vue 2 和 Vue 3 中的异步处理（例如，使用 <code>async</code> 和 <code>await</code>）。</strong></p><ul><li>Vue 2 和 Vue 3 都支持使用 <code>async</code> 和 <code>await</code> 进行异步处理。</li><li>Vue 3 的 Composition API 可以更方便地与异步处理结合。</li></ul><p>以上分块回答了 Vue 2 和 Vue 3 对比的面试题，涵盖了从基础特性到实际应用的各个方面。希望这些回答能够帮助你更好地准备面试。</p><h2 id="vue3-diff-算法优化" tabindex="-1">vue3 diff 算法优化 <a class="header-anchor" href="#vue3-diff-算法优化" aria-label="Permalink to &quot;vue3 diff 算法优化&quot;">​</a></h2><p>Vue 3 使用 Virtual DOM（虚拟 DOM） 来高效地更新和渲染用户界面。Vue 3 的 Virtual DOM diff 算法已经被优化，以提供更高的性能和更好的可维护性。以下是 Vue 3 Virtual DOM diff 算法的核心概念和工作原理：</p><h3 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h3><ol><li><p><strong>虚拟 DOM</strong>：虚拟 DOM 是组件的 JavaScript 对象表示形式，类似于一个轻量级的 DOM 结构。每次状态变化时，Vue 3 会创建一个新的虚拟 DOM 树。</p></li><li><p><strong>Diff 算法</strong>：Diff 算法的主要目的是找出新旧虚拟 DOM 树之间的差异，并将这些差异最小化地应用到实际的 DOM 上。</p></li></ol><h3 id="diff-算法的工作原理" tabindex="-1">Diff 算法的工作原理 <a class="header-anchor" href="#diff-算法的工作原理" aria-label="Permalink to &quot;Diff 算法的工作原理&quot;">​</a></h3><p>Vue 3 的 diff 算法基于一些优化策略和假设来提高性能：</p><ol><li><p><strong>同层比较</strong>：新旧虚拟 DOM 树在同一层级进行比较，不跨层级比较。这样可以避免复杂度为 O(n^3) 的完全对比，降低到 O(n)。</p></li><li><p><strong>双端比较</strong>：Vue 3 的 diff 算法使用了一种优化的双端比较策略，从前到后、从后到前同时进行比较。这种策略可以在实际应用中显著减少需要移动的 DOM 节点数量。</p></li><li><p><strong>相同类型节点的比较</strong>：Vue 3 假设同类型的节点才会有比较的可能性。如果节点类型不同，则直接替换，不进行深入比较。</p></li></ol><h3 id="具体步骤" tabindex="-1">具体步骤 <a class="header-anchor" href="#具体步骤" aria-label="Permalink to &quot;具体步骤&quot;">​</a></h3><p>以下是 Vue 3 Virtual DOM diff 算法的具体步骤：</p><ol><li><p><strong>同类型节点的比较</strong>：首先比较节点的类型，如果类型不同，则直接替换。如果类型相同，则进行下一步的详细比较。</p></li><li><p><strong>节点属性的比较</strong>：比较新旧节点的属性（如 class、style、事件等），找出不同之处并进行更新。</p></li><li><p><strong>子节点的比较</strong>：递归地对比子节点。如果子节点是纯文本，则直接比较文本内容；如果是元素节点，则进行同类型节点的比较。</p></li><li><p><strong>双端比较策略</strong>：</p><ul><li><strong>从左到右比较</strong>：依次比较新旧节点的第一个节点，如果相同则继续比较下一个。</li><li><strong>从右到左比较</strong>：依次比较新旧节点的最后一个节点，如果相同则继续比较前一个。</li><li><strong>中间节点的处理</strong>：在从左到右、从右到左比较后，如果中间部分还有未比较的节点，则使用键值对（keyed）的方式进行处理，找出可以复用的节点进行移动。</li></ul></li></ol><h3 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-label="Permalink to &quot;代码示例&quot;">​</a></h3><p>假设有两个虚拟 DOM 树 <code>oldVNode</code> 和 <code>newVNode</code>，diff 算法的核心思想可以简化为以下伪代码：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> diff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 比较节点类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldVNode.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVNode.type) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    replaceNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 比较节点属性</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    patchProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode, newVNode);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 比较子节点</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    diffChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldVNode.children, newVNode.children);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> diffChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEndIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newEndIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 双端比较</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEndIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEndIdx) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sameVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldChildren[oldStartIdx], newChildren[newStartIdx])) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      diff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldChildren[oldStartIdx], newChildren[newStartIdx]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      oldStartIdx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      newStartIdx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sameVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldChildren[oldEndIdx], newChildren[newEndIdx])) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      diff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldChildren[oldEndIdx], newChildren[newEndIdx]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      oldEndIdx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      newEndIdx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 中间部分处理</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 使用 key 对应进行复用和移动操作</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 具体实现略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理新增和删除的节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (oldStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldEndIdx) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    addNewNodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newChildren, newStartIdx, newEndIdx);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newEndIdx) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    removeOldNodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldChildren, oldStartIdx, oldEndIdx);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sameVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b.type;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> patchProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 比较并更新属性</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 具体实现略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addNewNodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">startIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">endIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 添加新节点</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 具体实现略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeOldNodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">startIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">endIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 移除旧节点</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 具体实现略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>Vue 3 的 Virtual DOM diff 算法通过优化策略和假设，显著提高了性能。主要通过同层比较、双端比较和键值对处理，实现了高效的 DOM 更新。理解这些原理有助于开发者更好地优化和调试 Vue 应用。</p><h2 id="vue2和vue3组件初始化的区别" tabindex="-1">vue2和vue3组件初始化的区别 <a class="header-anchor" href="#vue2和vue3组件初始化的区别" aria-label="Permalink to &quot;vue2和vue3组件初始化的区别&quot;">​</a></h2><p>Vue 3 在组件初始化方面对 Vue 2 做了许多优化和改进。以下是 Vue 2 和 Vue 3 组件初始化过程的详细对比：</p><h3 id="vue-2-组件初始化过程" tabindex="-1">Vue 2 组件初始化过程 <a class="header-anchor" href="#vue-2-组件初始化过程" aria-label="Permalink to &quot;Vue 2 组件初始化过程&quot;">​</a></h3><ol><li><p><strong>实例化组件</strong>：</p><ul><li>创建 Vue 实例，初始化选项（<code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 等）。</li><li>使用 <code>Object.defineProperty</code> 为每个属性设置 getter 和 setter，以实现响应式。</li></ul></li><li><p><strong>处理组件选项</strong>：</p><ul><li>合并父组件传递的选项和自身的选项。</li><li>初始化生命周期钩子。</li></ul></li><li><p><strong>调用生命周期钩子</strong>：</p><ul><li><code>beforeCreate</code> 和 <code>created</code>：组件实例已创建，但尚未挂载。</li></ul></li><li><p><strong>创建虚拟 DOM 树</strong>：</p><ul><li>执行 <code>render</code> 函数，生成虚拟 DOM 树。</li></ul></li><li><p><strong>挂载组件</strong>：</p><ul><li>执行 <code>beforeMount</code> 钩子。</li><li>生成实际的 DOM 并插入到文档中。</li><li>执行 <code>mounted</code> 钩子。</li></ul></li></ol><h3 id="vue-3-组件初始化过程" tabindex="-1">Vue 3 组件初始化过程 <a class="header-anchor" href="#vue-3-组件初始化过程" aria-label="Permalink to &quot;Vue 3 组件初始化过程&quot;">​</a></h3><ol><li><p><strong>实例化组件</strong>：</p><ul><li>创建组件实例，初始化组件的内部状态，包括数据、属性、方法等。</li><li>使用 Proxy 进行响应式数据的追踪，覆盖了更多的操作类型。</li></ul></li><li><p><strong>处理组件选项</strong>：</p><ul><li>合并组件的选项，如 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>、生命周期钩子等。</li><li>初始化响应式系统，使用 Vue 3 的 Proxy API 来实现响应式数据绑定。</li></ul></li><li><p><strong>调用 <code>setup</code> 函数</strong>（如果是组合式 API）：</p><ul><li>在组合式 API 中，调用 <code>setup</code> 函数，执行逻辑代码，返回的内容将被合并到组件实例中。</li></ul></li><li><p><strong>生命周期钩子</strong>：</p><ul><li><code>beforeCreate</code> 和 <code>created</code>：组件实例已创建，但尚未挂载。</li></ul></li><li><p><strong>创建虚拟 DOM 树</strong>：</p><ul><li>执行 <code>render</code> 函数，生成组件的虚拟 DOM 树。</li></ul></li><li><p><strong>挂载组件</strong>：</p><ul><li>通过 <code>mount</code> 方法，将组件挂载到真实 DOM 上。</li><li>调用 <code>beforeMount</code> 生命周期钩子。</li></ul></li><li><p><strong>生成和插入真实 DOM</strong>：</p><ul><li>根据虚拟 DOM 树生成实际的 DOM 元素，并插入到父节点中。</li><li>调用 <code>mounted</code> 生命周期钩子。</li></ul></li></ol><h3 id="关键区别" tabindex="-1">关键区别 <a class="header-anchor" href="#关键区别" aria-label="Permalink to &quot;关键区别&quot;">​</a></h3><ol><li><p><strong>响应性系统</strong>：</p><ul><li><strong>Vue 2</strong> 使用 <code>Object.defineProperty</code>，仅能侦听已有属性的变化。</li><li><strong>Vue 3</strong> 使用 Proxy，能够更全面地侦听对象和数组的变化。</li></ul></li><li><p><strong>组合式 API</strong>：</p><ul><li><strong>Vue 2</strong> 使用选项式 API（Options API），如 <code>data</code>、<code>methods</code>、<code>computed</code> 等。</li><li><strong>Vue 3</strong> 引入了组合式 API，通过 <code>setup</code> 函数组织和复用逻辑代码，使得代码更加模块化和可维护。</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li><strong>Vue 3</strong> 对组件的初始化和更新过程进行了许多性能优化，例如减少渲染开销、优化虚拟 DOM diff 算法。</li></ul></li><li><p><strong>生命周期钩子</strong>：</p><ul><li><strong>Vue 3</strong> 中生命周期钩子的调用顺序和方式与 Vue 2 基本一致，但由于 <code>setup</code> 函数的引入，可能会有一些细微的变化。</li></ul></li></ol><h3 id="示例代码对比" tabindex="-1">示例代码对比 <a class="header-anchor" href="#示例代码对比" aria-label="Permalink to &quot;示例代码对比&quot;">​</a></h3><p><strong>Vue 2 组件示例</strong>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue 2 组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello Vue 2&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  created</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Component created&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Component mounted&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Hello World&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><strong>Vue 3 组件示例</strong>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue 3 组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref, defineComponent } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello Vue 3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> updateMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      message.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Hello World&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      message,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      updateMessage</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  created</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Component created&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Component mounted&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.message }&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>Vue 3 通过使用 Proxy 进行响应式数据追踪和引入组合式 API，大幅提升了框架的性能和灵活性。组件初始化过程中的这些改进，使得 Vue 3 在开发大型和复杂应用时，具备更好的可维护性和可扩展性。</p>`,95),e=[t];function p(h,k,d,r,E,o){return a(),i("div",null,e)}const y=s(l,[["render",p]]);export{c as __pageData,y as default};
